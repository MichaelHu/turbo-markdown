<style type="text/css">
.content-search {
    position: fixed;
    top: 50%;
    left: 50%;
    width: 80%;
    max-width: 520px;
    margin-left: -260px;
    padding: 10px 20px;
    border: 1px solid #bbb;
    border-radius: 4px;
    background-color: #fff;
    /* box-shadow: h-shadow v-shadow blur spread color inset; */
    box-shadow: -3px -1px 3px #ccc;
}
@media screen and ( max-width: 600px ) {
    .content-search {
        margin-left: -40%;
    }
}
.content-search__text {
    width: 100%;
    height: 46px;
    box-shadow: none !important;
    border-width: 0 0 2px 0;
    border-radius: 0 !important;
    font-size: 24px !important;
    line-height: 32px !important;
    text-align: center;
}
.content-search_highlight {
    background-color: #ff0 !important;
}
.content-search_hide {
    display: none !important;
}

.content-search-info {
    position: fixed;
    top: 20px;
    right: 20px;
    min-width: 100px;
    height: 50px;
    padding: 0 8px;
    border: 2px solid #ccc;
    border-radius: 4px;
    background-color: #eee;
    text-align: center;
    line-height: 50px;
}
.content-search-info__current {
    font-size: 30px;
    color: #ff7f0e;
}
.content-search-info__splitter {
    margin: 0 3px;
    font-size: 20px;
    color: #bbb;
}
.content-search-info__total {
    font-size: 20px;
    color: #ffbb78;
}
</style>
</body>
</html>
<script type="text/javascript" src="http://258i.com/docs/markdown_res/bootstrap/js/bootstrap.min.js"></script>
<script type="text/javascript" src="http://258i.com/docs/markdown_res/js/scrollspy.js"></script>
<script type="text/javascript" src="http://258i.com/docs/markdown_res/js/lazyload.min.js"></script>
<script type="text/javascript" src="http://258i.com/docs/markdown_res/js/augment.js"></script>
<script type="text/javascript">
( function() {

document.title = $('h1').html() || '无标题文档';
$( '.lazy' ).lazyload( {
    data_attribute: 'url'
    // , effect : "fadeIn"
} );

} )();
</script>

<script>
( function() {

    $.fn.extend( {
        animateCss: function ( animationName, onFinish ) {
            var animationEnd = [
                    'webkitAnimationEnd'
                    , 'mozAnimationEnd'
                    , 'MSAnimationEnd'
                    , 'oanimationend'
                    , 'animationend'
                ].join( ' ' );
            this.addClass('animated ' + animationName)
                .one( animationEnd, function() {
                    $( this ).removeClass( 'animated ' + animationName );
                    'function' == typeof onFinish  && onFinish.apply( this );
                });
            return this;
        }
    } );

} )();
</script>

<script>
// search
( function() {


var STOP_TRAVEL = Number.MAX_VALUE;
var STATE_NORMAL = 1;
var STATE_BEFORE_SEARCH = 2;
var STATE_SEARCHING = 3;
var STATE_AFTER_SEARCH = 4;
var SELECTOR_PREFIX = '%:';

var disableSearch = null; 
var styleClasses = {
    hilight: 'content-search_highlight'
    , hide: 'content-search_hide'
};
var regSelectorPrefix = new RegExp( '^' + escapeRegExp( SELECTOR_PREFIX ) );

var currentResultIndex = 0;
var searchState = STATE_NORMAL; 
var lastKeyIsG = false;

function setState( state ) {
    var isValidState = [ 
            STATE_NORMAL, STATE_BEFORE_SEARCH
            , STATE_SEARCHING, STATE_AFTER_SEARCH 
        ].indexOf( state ) >= 0;

    if ( ! isValidState ) {
        throw new Error( 'setState( state ): invalid state' );
    }
    console.log( 'state: ' + state );
    searchState = state;
}

function getState() {
    return searchState;
}

// just fot testing
// updateSearchInfo( { current: 20, total: 192 } );

$( document ).on( 'keydown', function( e ) {

    var SLASH = 191, ESC = 27
        , G_KEY = 71, N_KEY = 78
        , J_KEY = 74, K_KEY = 75
        , U_KEY = 85, D_KEY = 68
        ;
    var keyCode = e.keyCode || e.which;
    var tagName = e.target.tagName || '';

    if ( keyCode == ESC 
        && getState() != STATE_NORMAL ) {
        // back to normal state
        restore();

        // bugfix for reopening the search bar
        $( '#content-search input' ).blur();
        disableSearch && disableSearch();
        closeSearchInfo();

        // state transformation
        setState( STATE_NORMAL );
    }

    if ( /input|textarea/i.test( tagName ) ) {
        // G-key state transformation
        lastKeyIsG = false;
        return;
    }

    if ( keyCode == G_KEY ) {
        if ( e.shiftKey ) {
            // go file end
            window.scrollBy( 0, $( document.body ).height() );
        }
        else {
            if ( ! lastKeyIsG ) {
                // G-key state transformation
                lastKeyIsG = true;
                // update state and leave
                return;
            }
            else {
                // go file start
                window.scrollTo( 0, 0 );
            }
        }
    }

    // G-key state transformation
    lastKeyIsG = false;

    if ( keyCode == SLASH ) {
        disableSearch = enableSearch();
        updateSearchInfo();

        /**
         * support searching again in last result,
         * we restore the dom tree, but keep the hidden item still hidden
         * , then the new searched result will not contain the hidden items
         * of last search
         */
        restore( { keepHiddenItems: true } );

        // state transformation
        setState( STATE_BEFORE_SEARCH );
    }
    else if ( keyCode == J_KEY ) {
        scrollByLine();
    }
    else if ( keyCode == K_KEY ) {
        scrollByLine( { operation: -1 } );
    }
    else if ( keyCode == D_KEY && e.ctrlKey ) {
        scrollByPage();
    }
    else if ( keyCode == U_KEY && e.ctrlKey ) {
        scrollByPage( { operation: -1 } );
    }
    else if ( keyCode == N_KEY 
        && searchState == STATE_AFTER_SEARCH
        ) {
        if ( e.shiftKey ) {
            gotoSearchResult( { operation: -1 } );
        }
        else {
            gotoSearchResult( { operation: 1 } );
        }
    }

});

$( document ).on( 'click', function( e ) {
    if ( getState() != STATE_AFTER_SEARCH
        || ! e.altKey ) {
        return;
    }
    showSibling( e.target );
} );

function updateSearchInfo( options ) {
    var opt = options || {};
    var $body = $( document.body );
    var $searchInfo = $( '#content-search-info' );

    if ( ! $searchInfo.length ) {
        $searchInfo = $( 
            '<div id="content-search-info" class="content-search-info">'
            + '<span class="content-search-info__current">18</span>' 
            + '<span class="content-search-info__splitter">/</span>' 
            + '<span class="content-search-info__total">100</span>' 
            + '</div>'
        );
        $body.append( $searchInfo );
    }

    $searchInfo.show();
    var $current = $searchInfo.find( '.content-search-info__current' );
    var $total = $searchInfo.find( '.content-search-info__total' );

    $current.text( opt.current || 0 );
    $total.text( opt.total || 0 );
}

function closeSearchInfo() {
    $( '#content-search-info' ).hide();
}

function showSibling( node ) {
    var $node = $( node );
    var $prev = $node.prev()
        , $next = $node.next()
        ;
    
    if ( $prev.hasClass( styleClasses.hide ) ) {
        $prev
            .removeClass( styleClasses.hide )
            .animateCss( 'fadeIn' )
            ; 
    }

    if ( $next.hasClass( styleClasses.hide ) ) {
        $next
            .removeClass( styleClasses.hide ) 
            .animateCss( 'fadeIn' )
            ; 
    }
}

function enableSearch() {
    var $body = $( document.body );
    var $searchBar = $( '#content-search' );

    if ( ! $searchBar.length ) {
        $searchBar = $( 
            '<div id="content-search" class="row content-search">'
            + '<div class="col">'
            + '<input class="form-control content-search__text" type="text">' 
            + '</div>'
            + '</div>'
        );
        $body.append( $searchBar );
    }

    var $searchInput = $searchBar.find( 'input' );
    $searchBar.show().fadeIn();
    setTimeout( function() { 
        $searchInput
            .val( '' )
            .focus()
            ; 
    } );

    $searchInput.on( 'keydown', function( e ) {
        var RETURN = 13, keyCode = e.keyCode || e.which;
        if ( keyCode == RETURN ) {
            // state transformation
            setState( STATE_SEARCHING );

            // initialize search info
            updateSearchInfo();

            var result = doSearch( this.value );

            // bugfix for reopening the search bar
            this.blur();

            disableSearch && disableSearch();

            // state transformation
            setState( STATE_AFTER_SEARCH );
        }
    } );

    return disableSearch || function() {
        $searchBar.fadeOut();
        $searchInput.off( 'keydown' );
    };
}


function escapeRegExp( text ) {
    // <https://github.com/sindresorhus/escape-string-regexp>
    if ( Object.prototype.toString.call( text ) != '[object String]' ) {
        throw new Error( 'escapeRegExp(): text must be a string' );
    }
    return text.replace( /[|\\{}().^$[\]*+?]/g, '\\$&' );
}

function matchSelectors( node, selectors ) {
    var isMatched = false;
    var selector;
    selectors = selectors || [];

    if ( ! node ) { 
        throw new Error( 'matchSelectors( node, selectors ): invalid argument - node' );
    }

    for ( var i = 0; i < selectors.length; i++ ) {
        selector = selectors[ i ];
        if ( /^#(.+)/.test( selector ) ) {
            if ( node.id == RegExp.$1 ) {
                isMatched = true;
                break;
            }
        }
        else if ( /^\.(.+)/.test( selector ) ) {
            var className = RegExp.$1;
            /**
             * Note: there is a bug when node is an `svg`: `if ( node.className ) ...`
             *  1. Object.prototype.toString.call( svgDOM.tagName ) == '[object SVGAnimatedString]'
             *  2. typeof svgDOM.className == object
             *  3. svgDOM.className.split is not a function
             */
            if ( typeof node.className == 'string'
                && node.className.split( /\s+/ ).indexOf( className ) >= 0 ) {
                isMatched = true;
                break;
            } 
        }
        else if ( Object.prototype.toString.call( selector ) == '[object RegExp]' ) {
            if ( node.tagName 
                && selector.test( node.tagName ) ) {
                isMatched = true;
                break;
            }
        }
        else {
            if ( node.tagName 
                && selector == node.tagName.toLowerCase() ) {
                isMatched = true;
                break;
            }
        }
    } 

    return isMatched;
}

function splitText( text, splitter ) {
    // Note: modifier 'g' here will trigger a bug
    // var reg = new RegExp( escapeRegExp( splitter ), 'ig' );
    var reg = new RegExp( escapeRegExp( splitter ), 'i' );
    var textArr = text.split( reg ); 
    var keysArr = [], f, t, i, start, end, key, lastIndex = 0;

    /**
     * the way below has a bug:
     *     text     splitter    textArr              keysArr 
     *     ==========================================================
     *     s        s        => [ "", "" ]           [ "" ]
     *     ss       s        => [ "", "", "" ]       [ "", "" ]
     *     as       s        => [ "a", "" ]          [ "" ]
     *     asbs     s        => [ "a", "b", "" ]     [ "s", "" ]
     */
    // if ( textArr.length > 1 ) {
    //     for ( i = 0; i < textArr.length - 1; i++ ) {
    //         f = textArr[ i ];
    //         t = textArr[ i + 1 ];
    //         start = lastIndex + f.length;
    //         end = text.indexOf( t, start );
    //         keysArr.push( text.substring( start, end ) );
    //         lastIndex = end;
    //     }
    // }

    /**
     * the bug-free way
     */
    if ( textArr.length > 1 ) {
        var tmpText = text;
        for ( i = 0; i < textArr.length - 1; i++ ) {
            f = textArr[ i ];
            start = f.length;
            tmpText = tmpText.substring( start );
            if ( ! reg.test( tmpText ) ) {
                throw new Error( 'splitText( text, splitter ): an error occured' );
            }
            key = RegExp[ '$&' ];
            keysArr.push( key );
            tmpText = tmpText.substr( key.length );
        }
    }

    return {
        textArr: textArr
        , keysArr: keysArr
    };
}


function doSearch( text, options ) {
    var opt = options || {};
    var $root = $( document.body );
    var searchResult;
    var hasMatched = false;

    // console.log( 'doSearch: ' + text );

    opt.highlightExcludes = opt.highlightExcludes || [
        '.content-search'
        , '.content-search-info'
        , styleClasses.hide
        , /style|script|iframe|input|textarea|svg|canvas/i
    ];

    opt.hideExcludes = opt.hideExcludes || [
        '#navbar-auto'
        , '.content-search'
        , '.content-search-info'
        , styleClasses.hide
        , /style|script|iframe|h[1-7]/i
    ];

    if ( ! text.replace( /^\s+|\s+$/, '' ).length ) {
        searchResult = false;
    }
    else if ( regSelectorPrefix.test( text ) ) {
        console.log( 'do selector search' );
        // searchResult = doSelectorSearch();
        searchResult = false;
    } 
    else {
        console.log( 'do content search' );
        searchResult = doContentSearch( text, opt );
    }

    if ( ! searchResult ) {
        $( '#content-search-info' ).animateCss( 'hinge' );
    }
    else {
        currentResultIndex = 0;
        gotoSearchResult();
    }

    return searchResult;
}

function doContentSearch( text, options ) {
    var opt = options;
    var $root = $( document.body );
    var hasMatched = false;

    // todo: opt validation

    preDepthTravel( $root[ 0 ], {
        visit: function( node ) {
            if ( matchSelectors( node, opt.highlightExcludes ) ) {
                return STOP_TRAVEL;
            }

            if ( node.nodeType == 3 ) { 
                var rawText = node.nodeValue;

                var splitResult = splitText( rawText, text );
                var textArr = splitResult.textArr;
                // the original keywords
                var keysArr = splitResult.keysArr;

                var newNodes = [];
                var parentNode = node.parentNode;
                if ( textArr.length > 1 ) {
                    hasMatched = true;
                    for ( var i = 0; i < textArr.length; i++ ) {
                        newNodes.push( document.createTextNode( textArr[ i ] ) );
                        if ( i < textArr.length - 1 ) {
                            var spanNode = document.createElement( 'span' );
                            var innerTextNode = document.createTextNode( keysArr[ i ] );
                            spanNode.appendChild( innerTextNode );
                            spanNode.className = styleClasses.hilight;
                            newNodes.push( spanNode );
                        }
                    }

                    for( i = 0; i < newNodes.length; i++ ) {
                        parentNode.insertBefore( newNodes[ i ], node );
                    }

                    parentNode.removeChild( node );
                    return newNodes.length - 1;
                }
            }
            return 0;
        }
    } );

    // if no matched, we don't need to hide no-matched elements
    if ( ! hasMatched ) {
        // $( '#content-search-info' ).animateCss( 'hinge' );
        return false;
    }

    preDepthTravel( $root[ 0 ], {
        visit: function( node ) {
            if ( matchSelectors( node, opt.hideExcludes ) 
                // #text nodes ignored
                || node.nodeType == 3 ) {
                return STOP_TRAVEL;
            }

            var $node = $( node );
            var className = styleClasses.hilight;
            if ( ! $node.find( '.' + className ).length 
                && ! $node.hasClass( className )
                ) {
                // console.log( node.tagName + ', ' + node.nodeName );
                var display = $node.css( 'display' );

                if ( ! allTextChildren( node ) 
                    || display != 'inline' 
                        && display != 'inline-block'
                    ) {
                    $node.addClass( styleClasses.hide );
                }
                // do not hide inline elements those have only text child nodes
                else {
                    // console.log( 'allTextChildren: ' + node.nodeType );
                }
                return STOP_TRAVEL;
            }
            return 0;
        }
    } );

    // currentResultIndex = 0;
    // gotoSearchResult();

    return true;
}


function scrollByLine( options ) {
    var opt = options || {};
    opt.operation = opt.operation || 1;
    opt.lineHeight = opt.lineHeight 
        || parseInt( $( document.body ).css( 'line-height' ) );
    // console.log( 'scrollByLine: ' + opt.lineHeight );
    window.scrollBy( 0, opt.lineHeight * opt.operation );
}

function scrollByPage( options ) {
    var opt = options || {};
    opt.operation = opt.operation || 1;
    opt.pageHeight = opt.pageHeight 
        || $( window ).height();
    console.log( 'scrollByPage: ' + opt.pageHeight );
    window.scrollBy( 0, opt.pageHeight * opt.operation );
}

function clearHighlight() {
    $( '.' + styleClasses.hilight )
        .removeClass( styleClasses.hilight )
        ;
}

function gotoSearchResult( options ) {
    var opt = options || {};
    var $results = $( '.' + styleClasses.hilight )
        // we only care the visible results
        .filter( function( index ) {
            return $( this ).is( ':visible' );
        } )
        ;
    var len = $results.length;
    var $result;

    opt.operation = opt.operation || 0;

    if ( ! len ) {
        return;
    }

    setTimeout( function() {
        // make sure currentResultIndex not be a negative number
        currentResultIndex = ( len + currentResultIndex + opt.operation ) % len;
        $result = $( $results[ currentResultIndex ] );

        if ( $result[ 0 ].scrollIntoViewIfNeeded ) {
            // element.scrollIntoView( alignWithTop )
            $result[ 0 ].scrollIntoViewIfNeeded();
        }
        else {
            var pageHeight = $( window ).height();
            var offset = $result.offset();
            window.scrollTo( 0, offset.top - pageHeight / 2 ); 
        }

        updateSearchInfo( { current: currentResultIndex + 1, total: len } );
        // immediately after search
        if ( ! opt.operation ) {
            $( '#content-search-info' ).animateCss( 'jello' );
        }

        // point out the current searched item
        $result.animateCss( 'flash' );
    }, 0 );
}

// check if all children are text nodes
function allTextChildren( node ) {
    var textChildren = true;

    if ( ! node ) {
        throw new Error( 'allTextChildren( node ): node argument not supplied' );
    }

    if ( ! node.childNodes || ! node.childNodes.length ) {
        return false;
    }

    for ( var i = 0; i < node.childNodes.length; i++ ) {
        var child = node.childNodes[ i ];
        if ( child.nodeType != 3 ) {
            textChildren = false; 
            break;
        }
    }

    return textChildren;
}

function restore( options ) {
    var opt = options || {};
    var $root = $( document.body );

    preDepthTravel( $root[ 0 ], {
        visit: function( node ) {
            if ( node.tagName && node.tagName.toLowerCase() == 'span'
                && node.className.split( /\s+/ ).indexOf( styleClasses.hilight ) >= 0 
                ) {
                var t1 = node.childNodes[ 0 ];
                var t2 = node.previousSibling;
                var t3 = node.nextSibling;
                if ( t1.childNodes.length > 1
                    || ! t2 
                    || ! t3
                    ) {
                    throw new Error( 'restore(): an error occured' );
                }
                t2.nodeValue += t1.nodeValue + t3.nodeValue;
                node.parentNode.removeChild( node );
                t3.parentNode.removeChild( t3 );

                // we discard 2 nodes
                return -1;
            }
            return 0;
        }
    } );

    if ( opt.keepHiddenItems ) {
        return;
    }

    $( '.' + styleClasses.hide )
        .removeClass( styleClasses.hide )
        ;
}

function defaultVisit( node ) {
    console.log( 
        node.nodeName 
        + ' | ' + node.nodeValue 
        + ' | ' +  node.tagName 
    );
}

function preDepthTravel( node, options ) {
    var opt = options || {};
    var visit = opt.visit || defaultVisit;
    var childNodes = node.childNodes;
    var result = visit( node );

    // if STOP_TRAVEL, no traverse descendants
    if ( STOP_TRAVEL == result ) {
        return 0;
    }

    // if 0, childNodes no changed
    // if more than 0, there are new child nodes added
    for ( var i = 0; i < childNodes.length; i++ ) {
        i += preDepthTravel( childNodes[ i ], opt ); 
    }

    return result;
}




} )();
</script>
